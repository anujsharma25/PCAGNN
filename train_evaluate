class SimpleGNN:
    """
    A simple graph neural network model with one layer for node classification.
    Performs a graph convolution: out = A @ X @ W + b, where A is the adjacency matrix.
    """
    def __init__(self, input_dim, output_dim):
        """
        Initialize the model.

        Args:
            input_dim (int): Dimension of input node features.
            output_dim (int): Number of output classes.
        """
        # Initialize weights and biases randomly
        self.input_dim = input_dim
        self.output_dim = output_dim
        self.W = [[random.random() * 0.1 for _ in range(output_dim)] for _ in range(input_dim)]
        self.b = [random.random() * 0.1 for _ in range(output_dim)]
        self.is_training = True  # Flag for training/evaluation mode

    def train(self):
        """Set model to training mode."""
        self.is_training = True

    def eval(self):
        """Set model to evaluation mode."""
        self.is_training = False

    def forward(self, X, edge_index, num_nodes):
        """
        Forward pass: Compute A @ X @ W + b.

        Args:
            X (list of lists): Node feature matrix (n x input_dim).
            edge_index (list of tuples): List of [source, target] edges.
            num_nodes (int): Number of nodes.

        Returns:
            list of lists: Output matrix (n x output_dim) with class scores.
        """
        # Create adjacency matrix
        A = [[0] * num_nodes for _ in range(num_nodes)]
        for src, dst in edge_index:
            if 0 <= src < num_nodes and 0 <= dst < num_nodes:
                A[src][dst] = 1
                A[dst][src] = 1  # Undirected graph
        # Compute A @ X
        AX = matrix_multiply(A, X)
        # Compute A @ X @ W
        AXW = matrix_multiply(AX, self.W)
        # Add bias
        out = [[AXW[i][j] + self.b[j] for j in range(self.output_dim)] for i in range(num_nodes)]
        return out

def argmax(matrix, dim=1):
    """
    Compute the index of the maximum value along the specified dimension.

    Args:
        matrix (list of lists): Input matrix.
        dim (int): Dimension along which to compute argmax (1 for rows).

    Returns:
        list: Indices of maximum values.
    """
    if dim != 1:
        raise ValueError("Only dim=1 is supported")
    result = []
    for row in matrix:
        max_val = row[0]
        max_idx = 0
        for j in range(1, len(row)):
            if row[j] > max_val:
                max_val = row[j]
                max_idx = j
        result.append(max_idx)
    return result

def evaluate(model, data):
    """
    Evaluate the model's accuracy on the test set.

    Args:
        model: GNN model (SimpleGNN instance).
        data (dict): Dictionary containing:
            - x: Node feature matrix (n x input_dim).
            - edge_index: List of [source, target] edges.
            - y: Target labels (n, ) as a list of integers.
            - test_mask: List of booleans indicating test nodes.

    Returns:
        float: Accuracy as the fraction of correct predictions on test nodes.
    """
    # Set model to evaluation mode
    model.eval()
    
    # Forward pass to get class scores
    out = model.forward(data['x'], data['edge_index'], len(data['x']))
    
    # Compute predictions by taking argmax over class scores
    pred = argmax(out, dim=1)
    
    # Count correct predictions on test nodes
    correct = 0
    test_count = 0
    for i in range(len(data['test_mask'])):
        if data['test_mask'][i]:
            if pred[i] == data['y'][i]:
                correct += 1
            test_count += 1
    
    # Compute accuracy
    if test_count == 0:
        return 0.0  # Avoid division by zero
    acc = correct / test_count
    
    return acc

def print_matrix(matrix, name="Matrix"):
    """
    Print a matrix in a readable format.

    Args:
        matrix (list of lists): Matrix to print.
        name (str): Name of the matrix.
    """
    print(f"{name}:")
    for row in matrix:
        print([f"{x:.4f}" if isinstance(x, float) else f"{x}" for x in row])
    print()

# Example usage and testing
if __name__ == "__main__":
    import random
    # Example: Graph with 4 nodes, 2 features, 2 classes
    data = {
        'x': [
            [1.0, 2.0],
            [2.0, 1.0],
            [3.0, 3.0],
            [4.0, 2.0]
        ],
        'edge_index': [(0, 1), (1, 2), (2, 3)],
        'y': [0, 0, 1, 1],  # Binary classification labels
        'test_mask': [False, True, True, False]  # Test on nodes 1, 2
    }
    
    # Initialize model
    model = SimpleGNN(input_dim=2, output_dim=2)  # 2 classes
    
    # Evaluate model
    acc = evaluate(model, data)
    
    # Print results
    print(f"Test Accuracy: {acc:.4f}")
    out = model.forward(data['x'], data['edge_index'], len(data['x']))
    print_matrix(out, "Model Output (Class Scores)")
    pred = argmax(out, dim=1)
    print(f"Predictions: {pred}")
    print(f"True Labels: {data['y']}")
    print(f"Test Mask:   {data['test_mask']}")
